<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kitchen Vortex 3D – Landing Page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0e0b09;
      --bg-soft: #1a1410;
      --accent: #ff7b3b;
      --accent-soft: rgba(255, 123, 59, 0.1);
      --text: #f7f3ed;
      --muted: #c7bfb5;
      --radius-xl: 28px;
      --shadow-soft: 0 26px 60px rgba(0, 0, 0, 0.6);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #3d2b1f 0, #080605 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 20px clamp(20px, 4vw, 60px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(18px);
      background: linear-gradient(
        to bottom,
        rgba(8, 5, 3, 0.9),
        rgba(8, 5, 3, 0.3)
      );
      position: sticky;
      top: 0;
      z-index: 5;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: 14px;
    }

    .logo-mark {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #ffe2b3 0, #ff7b3b 40%, #f44336 100%);
      box-shadow: 0 0 18px rgba(255, 123, 59, 0.8);
    }

    .pill {
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      background: radial-gradient(circle at top left, #1f130c, #0b0705);
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4ade80;
      box-shadow: 0 0 14px rgba(74, 222, 128, 0.9);
    }

    main {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(20px, 5vw, 60px);
    }

    .hero {
      max-width: 1180px;
      width: 100%;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.1fr);
      gap: clamp(32px, 4vw, 60px);
      align-items: center;
    }

    .hero-copy {
      padding: clamp(18px, 3vw, 32px);
    }

    .eyebrow {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.17em;
      color: var(--muted);
      margin-bottom: 12px;
    }

    h1 {
      font-size: clamp(36px, 4vw, 48px);
      line-height: 1.05;
      margin-bottom: 18px;
    }

    h1 span {
      background: linear-gradient(120deg, #ffb454, #ff7b3b, #ff4d4d);
      -webkit-background-clip: text;
      color: transparent;
    }

    .hero-sub {
      color: var(--muted);
      font-size: 15px;
      line-height: 1.6;
      max-width: 460px;
      margin-bottom: 22px;
    }

    .hero-list {
      list-style: none;
      display: grid;
      gap: 9px;
      margin-bottom: 26px;
      font-size: 14px;
      color: var(--muted);
    }

    .hero-list li {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .hero-list li::before {
      content: "";
      width: 9px;
      height: 9px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #ffe8c1, #ff7b3b);
      box-shadow: 0 0 12px rgba(255, 123, 59, 0.8);
      flex-shrink: 0;
    }

    .hero-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .btn-primary {
      border: none;
      outline: none;
      padding: 13px 24px;
      border-radius: 999px;
      background: radial-gradient(circle at 20% 0, #ffe2b3, #ff7b3b);
      color: #20110a;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.7);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.15s ease;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.85);
      filter: brightness(1.02);
    }

    .btn-ghost {
      padding: 11px 18px;
      border-radius: 999px;
      background: rgba(18, 11, 8, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--muted);
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      backdrop-filter: blur(16px);
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .btn-ghost span.icon {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }

    .btn-ghost:hover {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(18, 11, 8, 0.95);
    }

    .hero-3d-shell {
      position: relative;
      padding: 10px;
    }

    .hero-3d-card {
      position: relative;
      border-radius: var(--radius-xl);
      background: radial-gradient(circle at 10% 0, #2b1c11, #050302 60%);
      box-shadow: var(--shadow-soft);
      padding: 14px;
      overflow: visible;
    }

    .hero-3d-glow {
      position: absolute;
      inset: auto 16% 8% 16%;
      height: 90px;
      background: radial-gradient(circle at 50% 0, rgba(255, 152, 68, 0.48), transparent 70%);
      opacity: 0.95;
      filter: blur(16px);
      z-index: 0;
      pointer-events: none;
    }

    .hero-3d-masked {
      position: relative;
      border-radius: 24px;
      overflow: hidden;
      background: radial-gradient(circle at 30% 0, #4a301f, #120a06 55%, #050202 92%);
      padding: 10px;
      /* Soft circular mask (CSS mask) */
      -webkit-mask-image: radial-gradient(circle at 50% 45%, #000 58%, transparent 90%);
      mask-image: radial-gradient(circle at 50% 45%, #000 58%, transparent 90%);
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
    }

    #vortex-canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 20px;
      filter: drop-shadow(0 22px 60px rgba(0, 0, 0, 0.9));
    }

    .hero-3d-label {
      position: absolute;
      left: 24px;
      top: 20px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(4, 2, 1, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.16);
      font-size: 11px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
      backdrop-filter: blur(18px);
      z-index: 2;
    }

    .hero-3d-label-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #4ade80;
      box-shadow: 0 0 12px rgba(74, 222, 128, 0.9);
    }

    .hero-3d-meta {
      position: absolute;
      right: 22px;
      bottom: 20px;
      padding: 10px 14px;
      border-radius: 18px;
      background: rgba(5, 4, 3, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 11px;
      color: var(--muted);
      backdrop-filter: blur(16px);
      z-index: 2;
      display: flex;
      flex-direction: column;
      gap: 2px;
      text-align: right;
      min-width: 150px;
    }

    .hero-3d-meta strong {
      color: var(--text);
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .hero-3d-meta span.emph {
      color: var(--accent);
    }

    @media (max-width: 900px) {
      main {
        padding-top: 10px;
      }
      header {
        position: static;
        background: none;
        backdrop-filter: none;
      }
      .hero {
        grid-template-columns: minmax(0, 1fr);
      }
      .hero-3d-shell {
        order: -1;
      }
    }

    @media (max-width: 600px) {
      .hero-3d-card {
        padding: 10px;
      }
      .hero-3d-masked {
        padding: 4px;
      }
      .hero-3d-label,
      .hero-3d-meta {
        transform: scale(0.92);
        transform-origin: center;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">
      <div class="logo-mark"></div>
      <span>Kitchen Vortex</span>
    </div>
    <div class="pill">
      <span class="pill-dot"></span>
      REAL-TIME 3D VORTEX
    </div>
  </header>

  <main>
    <section class="hero">
      <div class="hero-copy">
        <div class="eyebrow">Interactive Hero Section</div>
        <h1>
          Hyper-realistic <span>3D kitchen vortex</span> for your landing page.
        </h1>
        <p class="hero-sub">
          A floating green chili at the center of a miniature kitchen tornado. Utensils, vegetables,
          fruits, spices and droplets swirl in slow-motion loops, rendered in real-time 3D.
        </p>
        <ul class="hero-list">
          <li>GLTF / GLB assets, optimized for web.</li>
          <li>Looped 10–15s vortex animation with soft volumetric lighting.</li>
          <li>Cursor-driven parallax and scroll-reactive turbulence speed.</li>
        </ul>
        <div class="hero-actions">
          <button class="btn-primary">
            View 3D vortex
            <span>↻</span>
          </button>
          <button class="btn-ghost">
            <span class="icon">▶</span>
            Watch setup tutorial
          </button>
        </div>
      </div>

      <div class="hero-3d-shell">
        <div class="hero-3d-card">
          <div class="hero-3d-label">
            <span class="hero-3d-label-dot"></span>
            live gltf preview
          </div>
          <div class="hero-3d-masked">
            <!-- Three.js canvas -->
            <canvas id="vortex-canvas"></canvas>
          </div>
          <div class="hero-3d-meta">
            <strong>VORTEX LOOP</strong>
            <span>3×4 camera, cinematic depth</span>
            <span class="emph">Hover &amp; scroll to interact</span>
          </div>
          <div class="hero-3d-glow"></div>
        </div>
      </div>
    </section>
  </main>

  <!-- THREE.js scene (module script) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
    import { GLTFLoader } from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/GLTFLoader.js";

    const canvas = document.getElementById("vortex-canvas");
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      canvas
    });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.physicallyCorrectLights = true;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = null;

    // Depth-rich fog for atmosphere
    scene.fog = new THREE.FogExp2(0x0a0503, 0.12);

    // Camera setup – locked roughly in 3x4 framing
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
    camera.position.set(0, 1.1, 5);
    camera.lookAt(0, 0.4, 0);

    function resizeRenderer() {
      const { clientWidth, clientHeight } = canvas.parentElement;
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resizeRenderer);
    resizeRenderer();

    // ---------- Lighting ----------
    const keyLight = new THREE.DirectionalLight(0xfff2dc, 3.2);
    keyLight.position.set(-3, 6, 4);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(2048, 2048);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0xff8450, 2.0);
    rimLight.position.set(3, 2, -2);
    scene.add(rimLight);

    const fillLight = new THREE.AmbientLight(0xffd4a4, 1.0);
    scene.add(fillLight);

    // ---------- Floor / cutting board ----------
    const boardGroup = new THREE.Group();
    scene.add(boardGroup);

    const boardGeom = new THREE.BoxGeometry(3.2, 0.18, 2.2);
    const boardMat = new THREE.MeshStandardMaterial({
      color: 0x7a5233,
      roughness: 0.6,
      metalness: 0.05
    });
    const boardMesh = new THREE.Mesh(boardGeom, boardMat);
    boardMesh.position.set(0, -1.1, 0);
    boardMesh.receiveShadow = true;
    boardMesh.castShadow = true;
    boardGroup.add(boardMesh);

    const floorGeom = new THREE.PlaneGeometry(18, 18);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x2b1a12,
      roughness: 0.9,
      metalness: 0.0
    });
    const floorMesh = new THREE.Mesh(floorGeom, floorMat);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.position.y = -1.2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    // ---------- Central chili pepper (placeholder procedural mesh) ----------
    const chiliGroup = new THREE.Group();
    scene.add(chiliGroup);

    const chiliMat = new THREE.MeshPhysicalMaterial({
      color: 0x45aa2b,
      roughness: 0.22,
      metalness: 0.05,
      clearcoat: 0.5,
      clearcoatRoughness: 0.25
    });

    const chiliBody = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.21, 1.9, 16, 32),
      chiliMat
    );
    chiliBody.castShadow = true;
    chiliBody.position.set(0, 0.4, 0);
    chiliBody.rotation.z = 0.3;
    chiliGroup.add(chiliBody);

    const stemMat = new THREE.MeshStandardMaterial({
      color: 0x1f4f17,
      roughness: 0.5
    });
    const stem = new THREE.Mesh(
      new THREE.ConeGeometry(0.09, 0.32, 12),
      stemMat
    );
    stem.position.set(0.15, 1.4, 0);
    stem.rotation.z = 1.7;
    stem.castShadow = true;
    chiliGroup.add(stem);

    // ---------- Vortex participants (vegetables, utensils, particles) ----------
    const vortexGroup = new THREE.Group();
    scene.add(vortexGroup);

    const orbitItems = [];

    function createOrbitItem(opts) {
      const {
        radius,
        height,
        speed,
        kind,
        phase,
        color,
        scale,
        tilt = 0
      } = opts;

      let mesh;

      switch (kind) {
        case "utensil":
          // simple stylised spoon / fork body
          const handleGeom = new THREE.CylinderGeometry(0.03, 0.03, 0.9, 16);
          const headGeom = new THREE.SphereGeometry(0.12, 16, 16);
          const metalMat = new THREE.MeshStandardMaterial({
            color: 0xd0d0d0,
            roughness: 0.15,
            metalness: 0.85
          });

          const utensil = new THREE.Group();
          const handle = new THREE.Mesh(handleGeom, metalMat);
          const head = new THREE.Mesh(headGeom, metalMat);
          handle.position.y = 0.3;
          head.position.y = 0.9;
          utensil.add(handle);
          utensil.add(head);
          utensil.scale.setScalar(scale);
          mesh = utensil;
          break;

        case "veg":
          const vegGeom = new THREE.SphereGeometry(0.18, 24, 24);
          const vegMat = new THREE.MeshStandardMaterial({
            color,
            roughness: 0.35,
            metalness: 0.05
          });
          mesh = new THREE.Mesh(vegGeom, vegMat);
          mesh.scale.setScalar(scale);
          break;

        case "slice":
          const sliceGeom = new THREE.CylinderGeometry(0.22, 0.22, 0.08, 32);
          const sliceMat = new THREE.MeshStandardMaterial({
            color,
            roughness: 0.4
          });
          mesh = new THREE.Mesh(sliceGeom, sliceMat);
          mesh.rotation.x = Math.PI / 2;
          mesh.scale.multiplyScalar(scale);
          break;

        default:
          const particleGeom = new THREE.SphereGeometry(0.05, 10, 10);
          const particleMat = new THREE.MeshPhysicalMaterial({
            color,
            roughness: 0.1,
            transmission: 0.7,
            thickness: 0.3,
            metalness: 0
          });
          mesh = new THREE.Mesh(particleGeom, particleMat);
      }

      mesh.castShadow = true;
      vortexGroup.add(mesh);
      orbitItems.push({
        mesh,
        radius,
        height,
        speed,
        phase,
        kind,
        tilt
      });
    }

    // vegetables
    createOrbitItem({
      radius: 1.2,
      height: 0.3,
      speed: 0.55,
      kind: "veg",
      color: 0xff8242,
      phase: 0
    });
    createOrbitItem({
      radius: 1.45,
      height: 0.1,
      speed: 0.42,
      kind: "veg",
      color: 0xff4338,
      phase: Math.PI * 0.6
    });
    createOrbitItem({
      radius: 1.65,
      height: 0.65,
      speed: 0.3,
      kind: "veg",
      color: 0xfacc15,
      phase: Math.PI * 1.3
    });

    // slices
    createOrbitItem({
      radius: 1.4,
      height: -0.1,
      speed: 0.45,
      kind: "slice",
      color: 0xeab308,
      scale: 0.8,
      phase: Math.PI * 0.2,
      tilt: 0.4
    });
    createOrbitItem({
      radius: 1.8,
      height: -0.25,
      speed: 0.33,
      kind: "slice",
      color: 0xa855f7,
      scale: 0.7,
      phase: Math.PI * 0.9,
      tilt: -0.6
    });

    // utensils
    createOrbitItem({
      radius: 1.9,
      height: 0.7,
      speed: 0.27,
      kind: "utensil",
      scale: 1.0,
      phase: 0
    });
    createOrbitItem({
      radius: 2.1,
      height: 0.0,
      speed: -0.32,
      kind: "utensil",
      scale: 0.9,
      phase: Math.PI * 0.7
    });

    // spice droplets
    for (let i = 0; i < 40; i++) {
      createOrbitItem({
        radius: 1.0 + Math.random() * 1.4,
        height: -0.2 + Math.random() * 1.0,
        speed: 0.9 + Math.random() * 0.7,
        kind: "particle",
        color: Math.random() > 0.5 ? 0xffb454 : 0xf97316,
        phase: Math.random() * Math.PI * 2,
        scale: 1
      });
    }

    // ---------- Optional: load external GLB/GLTF assets ----------
    // Replace 'path/to/model.glb' with your own GLB or GLTF.
    // This demo uses procedural placeholders, but the loader is ready.
    const loader = new GLTFLoader();
    // Example:
    // loader.load("models/chili.glb", (gltf) => {
    //   gltf.scene.traverse((obj) => {
    //     if (obj.isMesh) {
    //       obj.castShadow = true;
    //       obj.receiveShadow = true;
    //     }
    //   });
    //   gltf.scene.scale.setScalar(1.0);
    //   gltf.scene.position.set(0, 0.4, 0);
    //   scene.remove(chiliGroup);
    //   scene.add(gltf.scene);
    // });

    // ---------- Interaction state ----------
    let mouseX = 0;
    let mouseY = 0;
    let scrollStrength = 0;

    window.addEventListener("mousemove", (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      mouseX = (x - 0.5) * 2; // -1..1
      mouseY = (y - 0.5) * 2;
    });

    window.addEventListener("scroll", () => {
      const max = 400;
      scrollStrength = Math.min(window.scrollY / max, 1);
    });

    // ---------- Animation loop ----------
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      const baseSpeed = 0.6;
      const speedBoost = 0.4 * scrollStrength;
      const turbulence = 0.08 + 0.05 * scrollStrength;

      // Camera subtle movement based on mouse
      camera.position.x = mouseX * 0.6;
      camera.position.y = 1.1 + mouseY * 0.4;
      camera.lookAt(0, 0.4, 0);

      // Chili floating
      chiliGroup.position.y = Math.sin(t * 1.5) * 0.08;
      chiliGroup.rotation.z = 0.3 + Math.sin(t * 0.7) * 0.12;
      chiliGroup.rotation.y = Math.sin(t * 0.4) * 0.2;

      // Vortex items
      orbitItems.forEach((item, i) => {
        const { mesh, radius, height, speed, phase, tilt, kind } = item;
        const dirSpeed = baseSpeed * speed + speedBoost * speed;
        const angle = t * dirSpeed + phase;

        const spiralOffset = turbulence * i * 0.004;

        const y =
          height +
          Math.sin(t * 1.2 + i * 0.3) * 0.15 +
          spiralOffset * (kind === "particle" ? 2 : 1);

        mesh.position.set(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius * 0.85
        );

        // Spin & face the center
        mesh.lookAt(0, 0.3, 0);
        mesh.rotation.z += tilt || 0;
        mesh.rotation.y += 0.02;

        if (kind === "particle") {
          mesh.rotation.x += 0.04;
        }
      });

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
