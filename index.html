<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Debug Redemoinho Suspiros</title>

  <!-- Three.js (mesmo CDN que você já usa) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      background: #050816; /* fundo escuro fixo */
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    #bg-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .label {
      position: fixed;
      top: 10px;
      left: 10px;
      font-size: 12px;
      opacity: 0.7;
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="bg-canvas"></canvas>
  <div class="label">Debug redemoinho – suspiro branco realista</div>

  <script>
    console.log("Debug redemoinho — suspiro realista branco");
    console.log("THREE disponível?", typeof THREE);

    // ========= FUNÇÃO: cria geometria de SUSPIRO REALISTA =========
    function createSuspiroGeometry() {
      const pts = [];
      const height = 1.0;

      // perfil radial (raio x altura) do suspiro
      const steps = 32;
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;         // 0 base, 1 topo
        const y = t * height;

        // base gordinha e topo afinando
        let r = 0.55 * Math.pow(1 - t, 0.25); // barriga
        r += 0.06 * (1 - t);                  // base mais marcada

        // leve afunilamento extra perto do topo
        if (t > 0.7) {
          r *= 0.6 + 0.4 * (1 - t);
        }

        // evita raio zero total antes da ponta
        r = Math.max(r, 0.05);

        pts.push(new THREE.Vector2(r, y));
      }

      // ponta fina
      pts.push(new THREE.Vector2(0.0, height * 1.08));

      // revolve o perfil para formar o suspiro
      const suspiroGeo = new THREE.LatheGeometry(pts, 64);
      suspiroGeo.rotateX(Math.PI); // ponta para baixo

      // aplicamos ranhuras + torção
      suspiroGeo.computeBoundingBox();
      const bb = suspiroGeo.boundingBox;
      const minY = bb.min.y;
      const maxY = bb.max.y;
      const hY = maxY - minY;

      const pos = suspiroGeo.attributes.position;
      const v = new THREE.Vector3();

      const ridgesCount = 14;   // número de “gomos”
      const ridgesStrength = 0.12; // intensidade das ranhuras
      const twistAmount = 0.8;  // torção da parte de cima

      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);

        const angle = Math.atan2(v.z, v.x);
        const radius = Math.sqrt(v.x * v.x + v.z * v.z);

        // ranhuras em volta
        const ridgeFactor = 1.0 + ridgesStrength * Math.sin(ridgesCount * angle);
        let newRadius = radius * ridgeFactor;

        // torção mais forte perto da ponta
        const t = (v.y - minY) / hY;  // 0 base, 1 topo
        const twist = twistAmount * t;
        const ca = Math.cos(twist);
        const sa = Math.sin(twist);

        // aplica raio modificado
        let x = Math.cos(angle) * newRadius;
        let z = Math.sin(angle) * newRadius;

        // aplica torção (rotação em Y)
        const rx = x * ca - z * sa;
        const rz = x * sa + z * ca;

        v.x = rx;
        v.z = rz;

        pos.setXYZ(i, v.x, v.y, v.z);
      }

      pos.needsUpdate = true;
      suspiroGeo.computeVertexNormals();

      // centraliza um pouco verticalmente
      suspiroGeo.translate(0, -height * 0.3, 0);

      return suspiroGeo;
    }

    // ========= CONFIG BÁSICA =========
    const canvas = document.getElementById('bg-canvas');
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: false
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x050816, 1); // mesmo fundo do body

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 0.5, 7); // afastado para ver o redemoinho inteiro

    // ========= LUZ =========
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.3);
    dirLight.position.set(3, 5, 4);
    scene.add(dirLight);

    // luz de preenchimento suave
    const fillLight = new THREE.DirectionalLight(0xfff5e8, 0.6);
    fillLight.position.set(-2, -1, -3);
    scene.add(fillLight);

    // ========= GRUPO DO REDEMOINHO =========
    const swirlGroup = new THREE.Group();
    scene.add(swirlGroup);
    swirlGroup.rotation.x = -0.4;

    // ========= GEOMETRIA E MATERIAL DO SUSPIRO =========
    const suspiroGeo = createSuspiroGeometry();

    const suspiroMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xfdf6f0,          // branco creme
      roughness: 0.45,
      metalness: 0.0,
      clearcoat: 0.8,
      clearcoatRoughness: 0.9,
      sheen: 0.4,
      sheenColor: new THREE.Color(0xffffff)
    });

    const suspiros = [];
    const count = 90;

    for (let i = 0; i < count; i++) {
      const mesh = new THREE.Mesh(suspiroGeo, suspiroMaterial);

      // escala geral do suspiro (ajuste fino)
      const scale = 0.6 + Math.random() * 0.15;
      mesh.scale.set(scale, scale, scale);

      const t = i / count;
      const turns = 3.0;
      const angle = t * turns * Math.PI * 2;

      const baseRadius = 0.4;
      const radius = baseRadius + t * 0.9;
      const height = (t - 0.5) * 2.0;

      mesh.position.set(
        Math.cos(angle) * radius,
        height,
        Math.sin(angle) * radius
      );

      mesh.position.x += (Math.random() - 0.5) * 0.05;
      mesh.position.y += (Math.random() - 0.5) * 0.05;
      mesh.position.z += (Math.random() - 0.5) * 0.05;

      mesh.rotation.y = Math.random() * Math.PI * 2;

      swirlGroup.add(mesh);
      suspiros.push({
        mesh,
        baseY: mesh.position.y,
        offset: Math.random() * Math.PI * 2
      });
    }

    // ========= RESIZE =========
    function onResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();

    // ========= MOUSE =========
    const mouse = new THREE.Vector2(0, 0);
    window.addEventListener('mousemove', (e) => {
      const x = (e.clientX / window.innerWidth) * 2 - 1;
      const y = (e.clientY / window.innerHeight) * 2 - 1;
      mouse.set(x, y);
    });

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // rotação do redemoinho
      swirlGroup.rotation.y = t * 0.22;

      // “respiração” leve dos suspiros
      for (const s of suspiros) {
        s.mesh.position.y = s.baseY + Math.sin(t * 1.3 + s.offset) * 0.1;
      }

      // câmera seguindo levemente o mouse
      const targetX = mouse.x * 0.25;
      const targetY = 0.5 + mouse.y * 0.15;
      camera.position.x += (targetX - camera.position.x) * 0.05;
      camera.position.y += (targetY - camera.position.y) * 0.05;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
